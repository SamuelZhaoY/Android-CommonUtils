apply plugin: 'java'

// ****** Tips1: Basic Ideas
// Gradle Task Life Cycle: 1.initialization, 2.configuration, 3.execution
task commonTask1

// This declaration run during configuration phase of block
// gradle -b build.gradle will invoke it
commonTask1 {
  println 'configuration block initialization'
}

// These two declaration run during execution
// gradle -b build.gradle commonTask1 will invoke them
commonTask1 << {
  println 'execution component1'
}

commonTask1 << {
  println 'execution component2'
}

commonTask1.doFirst
{
  println 'step 2'
}
commonTask1.doFirst
{
  println 'step 1'
}

commonTask1.doLast
{
  println 'step 3'
}

commonTask1.doLast
{
  println 'step 4'
}


// ****** Tips2: Dependency Declaration
// Tasks are all objects, which we can provide basic ways of declaring dependencies
task commonTask2 {

}

// Explicitly call the method on the task object task
commonTask2.dependsOn commonTask1

// A shortcut for dependencies only
//commonTask2(dependsOn: [commonTask1])



// ****** Tips3: Default task properties
// a. check finish run successfully
// tasks.compileJava.didWork

// b. check whether a specific task is enabled
// tasks.commonTask1.enabled

// c. setting a description information
// commonTask1.description = 'says hello to the world'


// ****** Tips4: Gradle task Types: Copy, Jar
task commonTask3(type: Copy) << {
  // Where from, into, include is method provided by Copy task type
  from 'resources'
  into 'target'
  include '**/*.xml', '**/*.txt', '**/*.properties'
}


// ***** Tips5: Create your own gradle type

task commonTask4(type: MySqlTask)
// Preset customized Task types
commonTask4 {
  sql = 'CREATE DATABASE IF NOT EXISTS example'
}


// ***** Tips6: Gradle provides powerful way to work with Ant ('there is a ant object which can execut ant command')
// Gradle & Ant can inject properties for each other; Gradle can import ant build file as a whole; Ant task can add dependency for gradle task


// ***** Tips7: There are several properties which you can configure inside of the dependencies blocks
task commonTask5(dependsOn: build) {
  configurations*.dependencies.each {println it}
}


// ***** Tips8: 'repositories' can be configed in multiple ways:

/* Add a customized file structure as repo
  add(new FileSystemResolver()) {
    name = "repo"
    addArtifactPattern("$rootDir/repo/[organization]/[module]-[revision].[ext]")
    addIvyPattern("$rootDir/repo/[organization]/ivy-[module]-[revision].xml")
    checkmodified = true
  }
*/

/* Config mvn, ivy like repo and account name
  ivy {
    name = 'ivyRepo'
    artifactPattern "http://repo.gradleware.org/[organisation]/[module]/ [revision]/[artifact]-[revision].[ext]"
  }
*/

/* Simple compile a whole list of file dir
  flatDir dirs: ['graphiclibs', guilibs']
*/


// ***** Tips9: Specify your own default tasks
//Alternate approach 1
//defaultTasks = ['clean', 'build']

//Alternate approach 2
//defaultTasks 'clean'

//Approach 3
//defaultTasks 'clean', 'build'


// ***** Tips10: Gradle can also be used to publish jar or aar to maven repo, also try using tool 'maven2gradle', understood meaning of buildScript


// --------     Advanced Gradle Topics   ---------


// ***** Tips11 File Operations: Copy, Filter , File(), Files(), FileTree()
/*
  When programming with file collections, it might be tempting to think of them as static lists.
  For example, a call to fileTree() might scan the filesystem at the time it is called, producing an immutable list that the build can then manipulate.
  Immutable data struc‐ tures have their uses, but in the Gradle lifecycle, this would make file collections difficult to use.
  As a result, instances of the FileCollection interface are lazily evaluated when‐ ever it is meaningful to do so.
*/


// ***** Tips12 Config your own customized plugin
